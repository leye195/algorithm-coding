/* 
-K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 
-숫자 N: 1 이상 10억 이하의 자연수
-숫자 K: 1 이상의 자연수
--N이 10억 이하의 자연수라는 제한이 있기 때문에 배열 활용 불가x 

처음에는 감도 안 잡혔지만 출발지점에서 부터 이동하는 것이 아닌
목적지점에서 부터 시작해서 출발지점으로 돌아가는 방법을 생각해보니
현재 위치가 홀수인 경우 매번 점프는 1칸 이동해 짝수로 만들고 순간이동을 진행하며 이동하면 
에너지 소비를 최소화 시킬수 있었음

-> 현재 위치%2===0 인 경우 순간이동, 현재 위치%2!==0 1칸 점프 
*/
function solution(n) {
  let ans = 0;
  while (n > 0) {
    if (n % 2 === 0) {
      //순간이동
      n = n / 2;
    } else {
      //한 칸 점프
      n = n - 1;
      ans++;
    }
  }
  return ans;
}
