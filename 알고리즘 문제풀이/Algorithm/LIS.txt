LIS (최장 증가 부분 수열) 알고리즘

원소가 n개인 배열의 일부 원소를 골라 만든 부분 수열 중, 각 원소가 이전 원소보다 큰다는 조건을 만족하고
그 길이가 최대인 부분 수열을 최장 증가 부분 수열일아고 한다.

ex) [6,2,5,1,7,4,8,3] 에서 LIS는 [2,5,7,8] 이 된다.

일반적으로 문제를 해결하는 가장 편한 방법은 DP를 이용하는것이다.

아래 코드에서 dp는 i번째 인덱스에서 끝나는 부분수열의 최장 수열길이를 의미한다.

```
const dp = new Array(n).fill(0);

for(let i=0;i<nums.length;i++) {
    for(let j=0;j<i;j++) {
        if(dp[i]>dp[j]) { 
            dp[i] = Math.max(dp[i],dp[j]+1);
        }
    }
}

return Math.max(...dp);
```

2중 for를 사용하고 있기 때문에 O(n^2) 의 시간 복잡도를 가진다. n이 100일 경우 10초 정도 걸린다고 예상 할 수 있다.

다른 한 가지 방법은 이분 탐색의 lower bounder를 활용하는 것이다.

LIS를 유지하기 위한 최적의 위치를 찾는데 lower bounder를 활용하기 때문에 O(nlgn) 시간복잡도를 가지게 된다.


```
const lowerBound = (arr,lo,hi,target) => {
    while(lo < hi) {
        const mid = Math.floor((lo+hi)/2);

        if(target <= arr[mid]) {
            hi = mid;
        } else {
            lo = mid+1;
        }
    }
    return lo;
}
const arr = [];
const n = nums.length;

for (let i = 0; i < nums.length; i++) {
  const target = nums[i];
  const idx = lowerBound(arr, 0, arr.length, target);

  if (idx >= arr.length) arr.push(target);
  else if (arr[idx] < target) arr[idx] = target;
}
return arr.length;
```

